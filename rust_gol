
fn live(mut a: &Vec<i32>, r: usize, col:usize, mut gen: i32)->i32{
  if (gen<1) {
    return 0;
  }
  let mut neighbours:i32=0;
  let mut rc:usize=r*col;

  let mut new: Vec<i32> = vec![0; rc];
  gen=gen-1;
  println!();
  println!("generation is {}",gen);
  for c in 0..a.len(){

    neighbours=checkValid(c.wrapping_sub(1),rc,&a)+checkValid(c.wrapping_sub(3),rc,&a)+checkValid(c.wrapping_sub(2),rc,&a)+checkValid(c.wrapping_sub(4),rc,&a)+checkValid((c+r-1),rc,&a)+checkValid((c+r),rc,&a)+checkValid((c+r+1),rc,&a)+checkValid((c+1),rc,&a);

    new[c]=0;
  
    if(a[c]==0)
    {
      if(neighbours==3)
      {
        new[c]=1;
      }
    }
    else
    {
      if (neighbours==2 || neighbours==3)
      {
        new[c]=1;
      }
    }
    if(c%3==0){
      println!{};
    }
    if (new[c]==1){
      print!{"O"};
    }
    else {
      print!{" "};
    }
  
  }
  
  live(&new,r,col,gen);
  return 0;
}

fn checkValid(n:usize,rc:usize,val:&[i32])->i32 {
    if(n>=0 && n<rc )
    {
      return val[n];
    }
    else
    {
      return 0;
    }
}


fn main() {
  let cols:usize = 3;
  let rows:usize = 3;
  let mut generations:i32 = 4;
  let mut count: Vec<i32> = Vec::with_capacity(cols*rows);
  count.push(0);
  count.push(0);
  count.push(0);
  count.push(1);
  count.push(1);
  count.push(1);
  count.push(1);
  count.push(0);
  count.push(0);
  println!("{:?}", &count);
   println!();
  println!("generation is {}",generations);
  for c in 0..count.len(){
    if(c%rows==0){
      println!{};
    }
    if count[c]==1{
      print!{"O"};
    }
    else {
      print!{" "};
    }
  }
  live(&count,rows,cols,generations);
}
